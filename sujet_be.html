<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>BE et Projet de Compilation</title>
  <style type="text/css">

      footer {
        padding-top: 10px;
        padding-bottom: 10px;
      }
      
      h1, h2, h3, h4, h5 {
        font-family: Sans-Serif;
        color: #993300;
        font-weight: normal;
      }
      
      tt, code {
        color: #993300;
      }
      
      pre {
        color: #993300;
        border-radius: 5px;
        border: 1px solid #993300;
        background: #ffff99;
        padding: 1ex;
        overflow: auto;
      }

      dt {
        color: #993300;
        font-family: Sans-Serif;
      }
      
      @media (max-width: 800px) {
        body > * {
          margin: 0%;
        }
      }
      @media (min-width: 800px) {
        body > * {
          margin: 1% 20% 1% 20%;
        }
      }
  </style>
</head>
<body>
  <h1>Compilation d'un petit langage</h1>
  
  <p>L'objectif de ce BE est d'écrire une grammaire ANTLR pour un
  petit langage appelé <em>Niklaus</em>, puis de compiler ce langage
  vers le langage d'assemblage du petit micro-processeur présenté en
  cours.</p>

  <h2>Le langage Niklaus</h2>
  
  <p>Niklaus est un langage impératif de type Pascal, C ou Java, très
    simplifié, qui est défini dans le cadre de ce BE pour vous
    permettre de traiter <em>complètement</em> du problème de la
    compilation sur un exemple simple.</p>
  
  <h3 id="structure-dun-programme">Structure d'un programme</h3>

  <p>En Niklaus il n'y a ni fonctions ni procédures. Un programme
    s'écrit d'un seul tenant. Les variables (voir ci-dessous) doivent
    être déclarées avant le corps du programme.</p>

  <p>Structure générale :</p>
  
<pre>program NomDuProgramme;
var variable1, variable2;  // liste des variables utilisées par le programme
{
    // corps du programme (bloc)
}</pre>

  <p>Un bloc, délimité entre accolades, permet de regrouper plusieurs
    instructions. Comme on le voit ci-dessus, le corps du programme
    est constitué d'un bloc.</p>
  
  <p>Sur une ligne, tout ce qui suit les symboles <code>//</code> est
    ignoré (commentaire).</p>

  <h3>Variables, constantes, expressions</h3>

  <p>Niklaus ne connaît qu'un seul type de données : le type entier
    (équivalent au <code>int</code> de Java). C'est pour cette raison
    que l'on n'indique pas de type lors de la déclaration des
    variables (voir exemple ci-dessus) : une variable
    est <em>implicitement</em> de type entier.</p>

  <p>De même, les constantes (littéraux) sont de type
    entier. Littéraux et variables peuvent être combinés pour former
    des expressions en utilisant les quatre opérations mathématiques
    de base, le modulo (<code>mod</code>), c'est-à-dire le reste de la
    division, ainsi que les parenthèses. On utilise la syntaxe infixe
    et les règles de priorité/associativité usuelles.</p>

  <p>Exemple : <code>3*(4+5) - b mod 2</code></p>

  <h3>Comparaisons</h3>
  
  <p>Comme indiqué ci-avant, Niklaus ne comporte pas d'expressions
    booléennes, mais il est nécessaire de former
    des <em>comparaisons</em> entre expressions (entières) pour les
    conditions des instructions conditionnelle et boucle. Une
    comparaison s'écrit :</p>
  
  <pre><code>expression1 opérateur expression2</code></pre>

  <p>où un opérateur peut
    être <code>&lt;</code>, <code>&lt;=</code>, <code>=</code>, <code>&lt;&gt;</code>
    (différent), <code>&gt;=</code>, <code>&gt;</code>.</p>

  <p>Exemple : <code> x+2 &lt;= y-6</code></p>

  <h3>Instructions</h3>

  <p>Toutes les instructions simples se terminent par un
    point-virgule. Plusieurs instructions peuvent être regroupées
    entre accolades pour former un bloc (qui n'est lui-même pas suivi
    de point-virgule).</p>

  <p>Niklaus dispose des instructions suivantes :</p>
  <dl>
    <dt>read : lecture d'un entier tapé au clavier</dt>
    <dd>
      Demande à l'utilisateur de taper un nombre entier au clavier, et
      le range dans une variable. 
    </dd>
  </dl>
  <p>Syntaxe : <code>read <em>variable</em>;</code></p>
  <dl>
    <dt>write : affichage de la valeur d'une expression</dt>
    <dd>
      Affiche la valeur d'une expression à l'écran.</dd>
  </dl>
  <p>Syntaxe : <code>write <em>expression</em>;</code></p>
  <dl>
    <dt>Affectation</dt>
    <dd>
      Range dans une variable la valeur d'une expression.<br />
    </dd>
  </dl>
  <p>Syntaxe : <code><em>variable</em>
      := <em>expression</em>;</code></p>
  <dl>
    <dt>Boucle « while »</dt>
    <dd>
      Répète une instruction, ou un bloc d'instructions, tant qu'une
      comparaison est vérifiée.<br />
    </dd>
  </dl>
  <p>Syntaxe : <code>while(<em>comparaison</em>) <em>instruction</em></code></p>
  <dl>
    <dt>Condition</dt>
    <dd>
      Selon qu'une comparaison est vérifiée ou non, effectue une
      instruction parmi deux alternatives.<br />
    </dd>
  </dl>
  <p>Syntaxe : <code>if(<em>comparaison</em>) <em>instruction1</em>
    else <em>instruction2</em></code> (note : la
    clause <code>else</code> est obligatoire).</p>

  <h3>Exemple</h3>

  <p>Le programme ci-dessous invite l'utilisateur à saisir deux
    nombres, puis il calcule leur PGCD par l'algorithme d'Euclide, et
    enfin l'affiche :</p>

  <pre><code>program PGCD;
var a, b;
{
    read a;
    read b;
    while(a &lt;&gt; b) {
        if(a &gt; b) {
            a := a - b;
        } else {
            b := b - a;
        }
    }
    write a;
}</code></pre>

  <h2>Travail demandé</h2>

  <ol>
    <li>
      <p><strong>Écrivez une grammaire ANTLR pour le langage
          Niklaus.</strong> Il vous est conseillé de partir du
          fragment fourni, qui correspond à la reconnaissance des
          expressions.</p></li>
    <li>
      <p>
        <strong>Rendez la grammaire la moins ambiguë possible afin
          d'alléger la phase d'analyse syntaxique.</strong>  Pour
          cela, utilisez <tt>grun</tt> avec
          l'option <tt>-diagnostics</tt> et vérifiez que les exemples
          valides du répertoire <tt>ProgrammesNiklaus</tt> ne génèrent
          pas de warnings.
      </p>
    </li>
    <li>
      <p><strong>Écrivez un programme qui génère du code d'assemblage
          en utilisant <tt>NiklausVisitor.py</tt></strong>, de façon à
          terminer la réalisation d'un compilateur pour le langage
          Niklaus. Utilisez ce que nous avons vu en cours et en TP la
          dernière fois !</p></li>

    <li><p><strong>Vérifiez que les codes d'exemples compilent
          correctement</strong> et que les programmes générés
          s'exécutent comme prévu. Ceux-ci se trouvent dans le
          répertoire <code>ProgrammesNiklaus</code>.</p>
    <li>
      <p>Faites les choses de façon <strong>progressive</strong>, en
      testant avec les codes données en exemple, et des codes ad-hoc
      pour chaque cas de figure.</p>

      <p>Le <strong>niveau de complétude</strong> de votre compilateur
      est donné comme suit:</p>
      <ol>
        <li>
          <p><code>write <em>constante</em></code>, est la seule
          instruction reconnue. Les problèmes de définition de
          variables sont traités.</p>
          <p>Codes de test:</p>
          <ul><li><code>undef.niklaus</code></li>
            <li><code>redef.niklaus</code></li>
            <li><code>basic.niklaus</code></li>
          </ul>
        </li>
        <li><p>Les variables sont traités: assignation, expression
            pouvant être une variable ou un
            entier. L'instruction <code>read</code> est
            traitée.</p>
          <p>Code de test:</p>
          <ul><li><code>var.niklaus</code></li>
          </ul>
        </li>
        <li><p>Les expressions de façon générique sont traitées
            (n'oubliez pas de mettre quelque chose
            dans <code>r6</code>...).</p>
          <p>Code de test:</p>
          <ul><li><code>calculations.niklaus</code></li>
          </ul>
        </li>
        <li><p>Les tests sont traités.</p>
          <p>Codes de test:</p>
          <ul><li><code>comp.niklaus</code></li>
            <li><code>test_if.niklaus</code></li>
          </ul>
        </li>
        <li><p>Les boucles sont traitées.</p>
          <p>Codes de test:</p>
          <ul><li><code>test_while_lt.niklaus</code></li>
            <li><code>pgcd.niklaus</code></li>
            <li><code>fibo.niklaus</code></li>
            <li><code>fact.niklaus</code> (que se passe-t-il en cas
            d'overflow ?</li></ul>
        </li>
      </ol>
    </li>
  </ol>

  <h3>À rendre</h3>

  <p><strong>Attention:</strong> travail individuel.</p>

  <ul>
    <li>le fichier <tt>Niklaus.g</tt>, mis à jour.</li>
    <li>les fichiers pythons</li>
    <li>un rapport en PDF présentant
      <ul><li>vos choix d'implémentation</li>
        <li>ce qui a été fait</li>
        <li>le <em>niveau de complétude</em> de votre code (voir au
          dessus)</li>
        <li>les problèmes rencontrés et les solutions
          choisies</li>
      </ul>
  </ul>
  
  <h3>Livraison en deux temps</h3>
  
  <ul>
    <li>À la fin du BE : ce que vous avez fait.</li>
    <li>Au vacances de Noël : l'ensemble du travail demandé.</li>
  </ul>

  <h2>Annexe : « Kit » fourni</h2>

  <h3>Contenu du kit</h3>

  <p>Le kit fourni est une archive ZIP qui contient :</p>
  <ul>
    <li><code>sujet_be.html</code> : ce fichier</li>
    <li><code>assembler.py</code> : code python transformant un code
    d'assemblage en un fichier <code>.mem</code> qui peut être charger
    par la machine de cours. Il s'agit du code de Frédéric
    Boulanger.</li>
    <li><code>antlr-4.9-complete.jar</code> : le fichier JAR
      d'ANTLR v.4.</li>
    <li><code>Niklaus.g</code> : une ébauche de grammaire pour Niklaus</li>
    <li><code>ProgrammesNiklaus/*.niklaus</code> : un ensemble de
      programmes de tests écrits en Niklaus. Votre
      compilateur <strong>doit</strong> avoir le comportement indiqué
      en commentaires au début du fichier.</li>
    <li><code>logisim-2.7.1.jar</code> : le fichier JAR de logisim, un
      émulateur de circuits booléens</li>
    <li><code>ese1010.jar</code> : une librairie pour logisim, qui
      doit se trouver dans le même répertoire pour être trouvée.</li>
    <li><code>miniARM_IO.circ</code> : le circuit du micro-processeur
      cible.</li>
    <li><code>test.arm</code> : un code d'assemblage de test</li>
    <li><code>lib.arm</code> : la librairie contenant les
      fonctions <code>readInt</code>, <code>printInt</code>,
      <code>readChr</code>, <code>printStr</code> présentées dans les
      transparents.</li>
  </ul>
  
  <h3>Prise en main du kit et configuration</h3>

  <ol>
    <li><p>Décompressez le kit dans un répertoire de votre choix.</p></li>

  <li><p>Assurez-vous d'être dans la configuration de la dernière fois, c'est à dire <a href="https://centralesupelec.edunao.com/pluginfile.php/115297/mod_resource/content/7/td.html">comme ce qui avait été fait pour les polynômes</a>. En particulier:</p>
  <ul>
    <li>
      Vous allez avoir besoin d'une installation Python3 et d'un compilateur java. Sous Windows, pour pouvoir avoir javac, il vous faut la JDK (par exemple <a href="https://www.oracle.com/java/technologies/javase-jdk15-downloads.html">ici</a>. Une fois installé, vous pouvez dans un terminal DOS placer la commande
        <pre>
SET PATH=C:\Program Files\Java\jdk_version\bin;%PATH%</pre>
       qui vous donnera accès à <tt>javac</tt>. Attention ! Utilisez évidemment le répertoire correspondant à votre config. En particulier, changez bien <tt>version</tt> par le nom du répertoire chez vous.
    </li>
    <li>
      Ceci étant acté, dans un premier temps je vous demanderai
      d'installer l'outil ANTLR v.4, en suivant les
      instructions <a href="https://github.com/antlr/antlr4/blob/master/doc/getting-started.md">ici</a>. L'objectif
      est que vous arriviez à faire tourner le tout petit exemple
      "hello world".
    </li>
    <li>La deuxième chose à faire est d'installer le package Python3 qui s'appelle <tt>antlr4-python3-runtime</tt> (la <a href="https://pypi.org/project/antlr4-python3-runtime/">doc est là</a>, mais il suffit de l'installer avec pip).</li>
    <li>Une fois ceci fait, vous pouvez continuer.</li>
  </ul>
  </li>

    <li><p>
        Testez la mini-grammaire <tt>Nilaus.g</tt> fournie avec le kit.
        <ul><li>Compilez-là avec les commandes
        <pre>antlr4 -Dlanguage=Java Niklaus.g
antlr4 -visitor  -Dlanguage=Python3 Niklaus.g
javac Niklaus*.java</pre>
        On ajoute les options de production de langage dans la ligne de commande. La version java permet d'utiliser l'outil de test <tt>grun</tt>, et la version Python de générer le fichier <tt>NiklausVisitor.py</tt> dont vous vous servirez pour faire votre compilateur (sur le même concept que ce qui a été fait <a href="https://centralesupelec.edunao.com/pluginfile.php/115297/mod_resource/content/7/td.html">la semaine dernière</a>.
          <li>Lancez <tt>grun</tt> pour tester:
            <pre>grun Niklaus expr -diagnostics -gui</pre>
            suivi d'une expression, comme <tt>x+3*(y-2)+8</tt>, puis <tt>^D</tt> si vous êtes sous *nix, ou <tt>^Z</tt> si vous êtes sous Windows.
          </li>
          <li>L'option <tt>-diagnostics</tt> permets de détecter des pesanteurs dans la grammaire: ambiguïtés par exemple, qui nécessitent une analyse lexicale plus poussée que ce qui pourrait potentiellement être nécessaire. Testez le type de warnings générés en ajoutant à la grammaire deux règles comme suit:
            <pre>b : a EOF;
a : a '+' a | ID '+' a | ID ;</pre>
            Ces deux règles introduisent une récursion à gauche, mais ce n'est pas un problème pour ANTLR v.4 qui va savoir les dé-récursifier (elle est simple). Notez par ailleurs le token <tt>EOF</tt> qui dénote... la fin de l'expression à analyser. Compilez avec
            <pre>antlr4 -Dlanguage=Java Niklaus.g
javac Niklaus*.java
grun Niklaus b -diagnostics</pre>
            Notez que nous testons le non-terminal <tt>b</tt>. Essayez l'expression <tt>x+y</tt> (suivi de <tt>^D</tt> ou <tt>^Z</tt> suivant votre système). Vous devriez voir ceci
            <pre>line 1:2 reportAttemptingFullContext d=3 (a), input='x+y'
line 2:0 reportAmbiguity d=3 (a): ambigAlts={1, 2}, input='x+y'</pre>
            Ce type de warning indiquent que cette expression ne peut pas être traité avec une méthode LL simple, et que donc des palliatifs (plus lents) ont été appliqués.
          </li>
          <li>Pour Niklaus, on vous demandera de vous assurer qu'aucun warning n'est émis (et que donc votre grammaire est aussi LL que possible).
            Vous pouvez par ailleurs effacer les deux lignes définissant <tt>a</tt> et <tt>b</tt> pour la suite...</li>
        </ul>
      </p></li>
  </ol>  
  
  
  <h4>Test de Logisim</h4>

  <ul>
    <li>Dans la console, entrez dans le répertoire du Kit, et sous
      linux tappez <code>java -jar logisim-2.7.1.jar
        miniARM_IO.circ</code>.</li>
    <li>Logisim devrait ouvrir le micro-processeur avec tous ses
      composants. Il est possible qu'il indique avoir besoin de la
      librairie <code>ese1010.jar</code> et vous demande où elle se
      trouve: lui indiquer (elle est dans le répertoire du Kit).</li>
    <li>Toujours dans une console, dans le répertoire du Kit, compilez
      le programme d'assemblage de test:
      <code>./assembler.py test.arm</code>. Cela devrait générer
      plusieurs fichiers, dont <code>test.mem</code>.</li>
    <li>Chargez ce fichier dans la mémoire du processeur, comme ce qui
      est indiqué dans les transparents du cours.</li>
    <li>Lancez la machine: en principe, on doit vous demander 2
      entiers, et le programme doit afficher différents résultats
      d'opérations arithmétiques.</li>
  </ul>
  
  <p>Si vous voulez en savoir plus, vous pouvez aller voir sur les
    pages suivantes, qui présentent une variante de la machine sans
    entrées-sorties.</p>

  <ul>
    <li><a href="http://wdi.centralesupelec.fr/architecture/BE/Ese1010-documentation">Documentation
        des composants de Logisim</a>.</li>
    <li><a href="http://wdi.centralesupelec.fr/architecture/Info/ARMCours">Le
        jeu d'instruction et leur encodage</a>.</li>
  </ul>


  <h4>Une alternative à Logisim</h4>

  <p>Si vous voulez une version plus légère, je peux vous proposer une
    implémentation de la machine en
    javascript <a href="https://www.monoidal.net/miniARM/">ici</a>.
    Une doc est accessible depuis la page. Ce qui n'est pas dit: si
    vous rechargez la page vous pouvez assembler et recharger un autre
    programme.<p>
    
    
  
    

  <h2>Annexe : Conseil de mise en oeuvre du compilateur</h2>
  
  <ul>
    <li><p>Mettez en place un parcours récursif ! En particulier, utilisez la même méthode que pour l'exercice de la fois dernière avec les polynômes. Étendez la classe <tt>NiklausVisitor</tt> pour faire votre générateur de code assembleur.</p></li>
    <li><p>L'avant dernier transparent du cours vous donne la liste des choses dans votre fichier d'assemblage, dans l'ordre...</p></li>
    <li><p>N'oubliez pas de gérer la fin du programme avec <code>@fin
          b fin</code>.</p></li>    
  </ul>

  <footer>
    <hr>
    <address>
      Benoit Valiron &lt;benoit.valiron@centralesupelec.fr&gt;
    </address>
  </footer>
</body>
</html>
